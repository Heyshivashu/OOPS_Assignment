# -*- coding: utf-8 -*-
"""OOPS_Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_n5s2-gKXZe21N1dodwq6m7acF4Nv1En

## Name: Shivanshu Singh Parihar
# Batch : September 2024
# Assignment Date: 16 Oct 2024
# Assignment : OOPS Assignment

###                                 Assignment -5

**Q1- What are the five key concepts of Object-Oriented Programming (OOP)?**

Ans -
The five key concepts of Object-Oriented Programming (OOP) are:

1. **Encapsulation**: This concept involves bundling the data (attributes) and methods (functions) that operate on the data into a single unit called a class. It restricts direct access to some of an object's components, which can prevent unintended interference and misuse.

2. **Abstraction**: Abstraction focuses on hiding complex implementation details and exposing only the essential features of an object. This allows developers to interact with objects at a high level without needing to understand the underlying complexities.

3. **Inheritance**: Inheritance allows a new class (subclass) to inherit properties and behaviors (methods) from an existing class (superclass). This promotes code reusability and establishes a hierarchical relationship between classes.

4. **Polymorphism**: Polymorphism enables objects of different classes to be treated as objects of a common superclass. It allows methods to do different things based on the object it is acting upon, typically implemented through method overriding and method overloading.

5. **Composition**: Composition is a design principle where a class is composed of one or more objects from other classes, allowing for a “has-a” relationship. This promotes flexibility and reusability by enabling complex types to be built from simpler ones.

These concepts work together to create a robust framework for organizing and managing code in a modular and efficient way.

**Q2-  Write a Python class for a `Car` with attributes for `make`, `model`, and `year`. Include a method to display the car's information.**
"""

class Car:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year

    def display_info(self):
        print(f"Car Information:\nMake: {self.make}\nModel: {self.model}\nYear: {self.year}")

my_car = Car("Honda", "i10", 2024)
my_car.display_info()

"""**Q3-  Explain the difference between instance methods and class methods. Provide an example of each.**


Ans - In Python, instance methods and class methods are two different types of methods that serve different purposes in a class. Here's an explanation of each along with examples:

 **Instance Methods**

Instance methods are functions defined within a class that operate on instances of that class. They take self as the first parameter, which refers to the specific instance of the class.
  
  **Purpose:** These methods can access and modify instance attributes.

"""

class Dog:
    def __init__(self, name):
        self.name = name

    def bark(self):
        print(f"{self.name} says Bhoo!")

# Example usage
my_dog = Dog("Toggo")
my_dog.bark()

"""**Class Methods**

Class methods are functions defined within a class that are bound to the class rather than its instances. They take cls as the first parameter, which refers to the class itself.
    
  **Purpose:** Class methods can be used to access class-level attributes and modify class state. They are decorated with @classmethod.
"""

class Dog:
    species = "labrodor"
    @classmethod
    def get_species(cls):
        return cls.species
print(Dog.get_species())

"""**Q4- How does Python implement method overloading? Give an example.**

Ans - Python does not support method overloading in the traditional sense, like some other languages e.g., Java or C++. Instead, Python allows us to define a method with the same name, but it does not automatically differentiate between them based on the number or type of arguments. The most recent definition of the method will overwrite the previous ones.

However, you can achieve similar behavior using default arguments or by using variable-length arguments args and kwargs. Here’s an example of how wecan simulate method overloading in Python:

"""

class Calculator:
    def add(self, a, b=0, c=0):
        return a + b + c

calc = Calculator()
print(calc.add(9))
print(calc.add(9, 20))
print(calc.add(9, 20, 25))

"""**Example Using Variable-Length Arguments**"""

class Calculator:
    def add(self, *args):
        return sum(args)
calc = Calculator()
print(calc.add(9))
print(calc.add(9, 5))
print(calc.add(9, 5, 10))
print(calc.add(1, 2, 3, 4, 5))

"""**Q5-  What are the three types of access modifiers in Python? How are they denoted?**

Ans - In Python, there are three types of access modifiers that control the visibility and accessibility of class members attributes and methods. They are:

 **1. Public**
Public members are accessible from outside the class. They can be accessed directly without any restrictions.
    
* Public members are defined without any special prefix.
"""

class MyClass:
    def __init__(self):
        self.public_attribute = "I am Shivanshu"

obj = MyClass()
print(obj.public_attribute)

"""**2. Protected**
Protected members are intended to be accessible within the class and its subclasses. They are not meant to be accessed directly from outside the class hierarchy.
    
* Protected members are denoted by a single underscore (_) prefix.
"""

class MyClass:
    def __init__(self):
        self._protected_attribute = "I am Data Anlysts"

class SubClass(MyClass):
    def access_protected(self):
        return self._protected_attribute

obj = SubClass()
print(obj.access_protected())

"""**3. Private**
Private members are meant to be accessible only within the class itself. They cannot be accessed from outside the class or by subclasses.
    
* Private members are denoted by a double underscore (__) prefix, which triggers name mangling (the interpreter changes the name of the variable to include the class name).
"""

class MyClass:
    def __init__(self):
        self.__private_attribute = "I am Social Media Specialist"

    def access_private(self):
        return self.__private_attribute

obj = MyClass()
print(obj.access_private())

"""**Q6-  Describe the five types of inheritance in Python. Provide a simple example of multiple inheritance.**
**Ans -** In Python, there are five main types of inheritance:

**1. Single Inheritance**

In single inheritance, a class (subclass) inherits from one superclass (base class).
"""

class Animal:
    def speak(self):
        return "Cat speak"

class Dog(Animal):
    def bark(self):
        return "Mews!"

dog = Dog()
print(dog.speak())
print(dog.bark())

"""**2. Multiple Inheritance**

In multiple inheritance, a class can inherit from more than one superclass. This allows the subclass to access attributes and methods from multiple parent classes.
"""

class Flyer:
    def fly(self):
        return "I can walk!"

class Swimmer:
    def swim(self):
        return "I can run!"

class Duck(Flyer, Swimmer):
    def quack(self):
        return "mews!"

duck = Duck()
print(duck.fly())
print(duck.swim())
print(duck.quack())

"""**3. Multilevel Inheritance**

In multilevel inheritance, a class inherits from a subclass, forming a hierarchy.
"""

class Animal:
    def speak(self):
        return "Animal speaks"

class Dog(Animal):
    def bark(self):
        return "Woof!"

class Puppy(Dog):
    def whimper(self):
        return "Whimper!"

puppy = Puppy()
print(puppy.speak())
print(puppy.bark())
print(puppy.whimper())

"""**4. Hierarchical Inheritance**

In hierarchical inheritance, multiple subclasses inherit from a single superclass.
"""

class Animal:
    def speak(self):
        return "Animal speaks"

class Dog(Animal):
    def bark(self):
        return "Woof!"

class Cat(Animal):
    def meow(self):
        return "Meow!"

dog = Dog()
cat = Cat()
print(dog.speak())
print(cat.speak())
print(dog.bark())
print(cat.meow())

"""**5. Hybrid Inheritance**

Hybrid inheritance is a combination of two or more types of inheritance. It can include multiple inheritance, multilevel inheritance, etc.

"""

class Animal:
    def speak(self):
        return "Animal sound"

class Dog(Animal):
    def speak(self):
        return "Bark"

class Puppy(Dog):
    def speak(self):
        return "Yip"

class Cat:
    def speak(self):
        return "Meow"

class Lion(Animal, Cat):
    def speak(self):
        return "Roar"

class HybridDog(Dog, Cat):
    def speak(self):
        return "Hybrid Bark and Meow"

if __name__ == "__main__":
    dog = Dog()
    puppy = Puppy()
    lion = Lion()
    hybrid_dog = HybridDog()

    print("Dog:", dog.speak())
    print("Puppy:", puppy.speak())
    print("Lion:", lion.speak())
    print("Hybrid Dog:", hybrid_dog.speak())

"""**Q7-  What is the Method Resolution Order (MRO) in Python? How can you retrieve it programmatically?**

Ans - Method Resolution Order (MRO) in Python is the order in which classes are looked up when searching for a method or an attribute. This is particularly important in multiple inheritance scenarios, where the same method might exist in more than one parent class.

**Python uses the C3 linearization algorithm to determine the MRO, ensuring that:**

 * A class is always considered before its parent classes.

* The order of parent classes is preserved.

* A class cannot appear before its parents in the MRO.

We can retrieve the MRO of a class using the __mro__ attribute or the mro() method.
"""

class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass

print(D.__mro__)
print(D.mro())

"""**Q8-  Create an abstract base class `Shape` with an abstract method `area()`. Then create two subclasses `Circle` and `Rectangle` that implement the `area()` method**

Ans -Here's how you can create an abstract base class Shape with an abstract method area(), and then create two subclasses, Circle and Rectangle, that implement the area() method.

We will use the abc module to define the abstract base class.
"""

from abc import ABC, abstractmethod
import math

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

"""Now, implement the Circle and Rectangle classes that inherit from Shape and define the area() method."""

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * (self.radius ** 2)

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

"""Now we can create instances of Circle and Rectangle and call their area() methods"""

circle = Circle(5)
print(f"Area of the circle: {circle.area():.2f}")

rectangle = Rectangle(4, 6)
print(f"Area of the rectangle: {rectangle.area()}")

"""**Q9 Demonstrate polymorphism by creating a function that can work with different shape objects to calculate and print their areas.**

Ans - Polymorphism allows us to use a common interface for different data types. In this case, we can create a function that accepts various shape objects and calculates their areas. Here’s how we can implement this using the previously defined Shape, Circle, and Rectangle classes.

*  Define the Shape Classes

Make sure we have the Shape, Circle, and Rectangle classes defined as shown before.

* Create the Polymorphic Function

We can create a function called print_area that takes a Shape object and prints its area.
"""

def print_area(shape):
    print(f"The area of the shape is: {shape.area():.2f}")

"""Now we can create instances of Circle and Rectangle, and pass them to the print_area function."""

circle = Circle(5)
rectangle = Rectangle(4, 6)

print_area(circle)
print_area(rectangle)

"""Here’s the complete code combining all the components:"""

from abc import ABC, abstractmethod
import math

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * (self.radius ** 2)

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

def print_area(shape):
    print(f"The area of the shape is: {shape.area():.2f}")

circle = Circle(5)
rectangle = Rectangle(4, 6)

print_area(circle)
print_area(rectangle)

"""**Q10- . Implement encapsulation in a `BankAccount` class with private attributes for `balance` and `account_number`. Include methods for deposit, withdrawal, and balance inquiry.**

Ans - Here's how you can implement encapsulation in a BankAccount class with private attributes for balance and account_number. This class will include methods for depositing, withdrawing, and inquiring about the balance.

**Implementation of the BankAccount Class**

"""

class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        self.__account_number = account_number  # Private attribute
        self.__balance = initial_balance         # Private attribute

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited: ${amount:.2f}")
        else:
            print("Deposit amount must be positive.")

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrew: ${amount:.2f}")
        else:
            print("Invalid withdrawal amount.")

    def get_balance(self):
        return self.__balance

    def get_account_number(self):
        return self.__account_number

if __name__ == "__main__":
    account = BankAccount("123456789", 1000)

    print(f"Account Number: {account.get_account_number()}")
    print(f"Initial Balance: ${account.get_balance():.2f}")

    account.deposit(500)
    print(f"New Balance: ${account.get_balance():.2f}")

    account.withdraw(200)
    print(f"New Balance: ${account.get_balance():.2f}")

    account.withdraw(2000)  # Invalid withdrawal

"""**Q11- . Write a class that overrides the `__str__` and `__add__` magic methods. What will these methods allow you to do?**

Ans -In Python, the __str__ and __add__ magic methods allow you to define custom behavior for string representation and addition operations, respectively. Here's a class that demonstrates both:

**Implementation of a Custom Class**

Let's create a class called Vector that represents a mathematical vector and overrides the __str__ and __add__ methods.
"""

class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented

if __name__ == "__main__":
    v1 = Vector(2, 3)
    v2 = Vector(5, 7)

    print(v1)           # Output: Vector(2, 3)
    print(v2)           # Output: Vector(5, 7)

    v3 = v1 + v2       # Using the __add__ method
    print(v3)          # Output: Vector(7, 10)

"""**Q12 Create a decorator that measures and prints the execution time of a function.**

Ans - We can create a decorator in Python that measures and prints the execution time of a function using the time module. Here’s how you can implement such a decorator:

**Implementation of the Execution Time Decorator**
"""

import time

def measure_execution_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Record the start time
        result = func(*args, **kwargs)  # Call the original function
        end_time = time.time()  # Record the end time
        execution_time = end_time - start_time  # Calculate the execution time
        print(f"Execution time of {func.__name__}: {execution_time:.4f} seconds")
        return result  # Return the result of the original function
    return wrapper

@measure_execution_time
def example_function(n):
    total = 0
    for i in range(n):
        total += i
    return total

result = example_function(1000000)

"""**Q13. Explain the concept of the Diamond Problem in multiple inheritance. How does Python resolve it?**
Ans - The Diamond Problem in multiple inheritance occurs when a class inherits from two classes that both inherit from a common superclass. This can create ambiguity about which method or attribute to use from the common ancestor, leading to potential conflicts.

**Consider the following class structure:**
"""

A
     / \
    B   C
     \ /
      D

"""**In this diagram:**

Class A is the superclass.
Classes B and C inherit from A.
Class D inherits from both B and C.


If both B and C override a method from A, and an instance of D calls that method, which version of the method should be used? This ambiguity is known as the Diamond Problem.

**Python's Resolution of the Diamond Problem**

Python resolves the Diamond Problem using the C3 Linearization algorithm (also known as the C3 superclass linearization). This algorithm provides a consistent method resolution order (MRO) that respects the order of inheritance and ensures that each class is called in a predictable way.

**MRO in Python**

The MRO defines the order in which classes are checked when calling a method or accessing an attribute. You can view the MRO of a class using the __mro__ attribute or the mro() method.

**Implementation**

Here's a concrete example to illustrate the Diamond Problem and how Python resolves it:
"""

class A:
    def method(self):
        return "Method from A"

class B(A):
    def method(self):
        return "Method from B"

class C(A):
    def method(self):
        return "Method from C"

class D(B, C):
    pass

d = D()

print(d.method())

print(D.__mro__)

"""**Q14-  Write a class method that keeps track of the number of instances created from a class.**

Ans - We can implement a class method that keeps track of the number of instances created from a class by maintaining a class-level attribute. Here’s how you can do that:

**Implementation of the Class with Instance Tracking**
"""

class InstanceCounter:
    instance_count = 0

    def __init__(self):
        InstanceCounter.instance_count += 1

    @classmethod
    def get_instance_count(cls):
        return cls.instance_count

if __name__ == "__main__":
    obj1 = InstanceCounter()
    obj2 = InstanceCounter()
    obj3 = InstanceCounter()

    print(f"Number of instances created: {InstanceCounter.get_instance_count()}")

"""**Q15- Implement a static method in a class that checks if a given year is a leap year.**

Ans - We can implement a static method in a class to check if a given year is a leap year. Here's how you can do that:

**Implementation of the Leap Year Checker**
"""

class YearUtils:
    @staticmethod
    def is_leap_year(year):
        """Check if a given year is a leap year."""
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            return True
        return False

if __name__ == "__main__":
    year = 2028
    if YearUtils.is_leap_year(year):
        print(f"{year} is a leap year.")
    else:
        print(f"{year} is not a leap year.")